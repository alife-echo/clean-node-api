# -- CONFIGURANDO DEPEDENCIAS

em tsconfig.json:


	esModuleInterop:true --> permite a adição de export e import em scripts que possui require
	allowjs:true --> permite a adição de arquivos de configuração em format js em vez de json dentro do dist



npm i git-commit-msg-linter --> adicionar um linter para git, ajuda a padronizar nossos commits

npm i eslint-config-standard-with-typescript --> adicionar o eslint , a padronizar nossos codigos

npm i -D husky --> adicionar o husk , caso o codigo não esteja padronizado ele bloqueia o commit

npm i -D lint-staged -> permite rodar script somente nos arquivos que estao nas areas do stage, os arquivos git add entram na area do stage, ajuda o husky a trabalhar apenas nos arquivos modificados

npm i -D jest @types/jest ts-jest --> instalação do jest

npm install --save-dev ts-node --> sempre instalar o ts-node para rodar o jest corretamente


em .eslintrc.json:
	
{
    "extends":"standard-with-typescript", --> apontar a depedencia que estamos usando
    "parserOptions": {
        "project":"./tsconfig.json" --> fazer com que o eslint trabalhe com o ts
    }
}


em .huskyrc.json 

"husky":{
    "hooks":{
        "pre-commit":"lint-staged" --> antes do commit, execute o lint-staged
    }
}
em .lintstagedrc.json
{          
    "*.{ts}": [
        "eslint 'src/**' --fix",
        "git add"
      ]
} --> vou verificar e corrigir a padronização de todos os arquivos ts, se der certo eu adiciono as alterações, se der errado, eu bloqueio o commit


em jest.config.js:
	  roots:['<rootDir>/src'], --> diretorio raiz de testes
	collectCoverage:['<rootDir>/src/**/*.ts'], --> especifico os arquivos para cobertura de teste
	coverageDirectory:'coverage', --> diretorio onde jest vai rodar os arquivos de cobertura
	testEnvironment:'node',--> os testes vão rodar em cima do node
	transform:{
	'.+\\.ts$':'ts-jest' --> qualquer texto com .ts no final eu quero utilizar nele o ts-jest 
}